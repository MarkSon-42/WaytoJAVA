// java call stack에 대한 상세한 설명 by chatGPT

//자바의 콜 스택(Call Stack)은 프로그램 실행 중에 메서드 호출 및 반환을 관리하는 중요한 데이터 구조입니다.
// 콜 스택은 메서드 호출의 순서와 각 메서드 호출의 상태를 추적하는 데 사용됩니다.
// 이것은 재귀 호출 및 메서드 호출 중 에러 추적과 같은 중요한 기능을 수행합니다.
// 아래에서 자바의 콜 스택에 대해 상세히 설명하겠습니다:
//
//        콜 스택의 동작:
//
//        콜 스택은 메서드 호출 및 반환을 추적하는 데 사용됩니다.
//        프로그램이 시작되면 메인 메서드(main)가 호출되고, 그 메서드에서 다른 메서드를 호출할 수 있습니다.
//        각 메서드 호출은 스택 프레임(Stack Frame)이라는 데이터 구조로 표현됩니다.
//        스택 프레임은 메서드 호출에 필요한 모든 정보(매개변수, 로컬 변수, 반환 주소 등)를 저장합니다.
//        스택 구조:
//
//        콜 스택은 스택 자료 구조의 형태를 가지며, 후입선출(LIFO, Last-In-First-Out) 원칙을 따릅니다.
//        가장 최근에 호출된 메서드가 스택 맨 위에 있고, 가장 오래된 메서드가 가장 아래에 위치합니다.

//        메서드 호출과 반환:
//
//        메서드가 호출되면 해당 메서드의 스택 프레임이 스택 맨 위에 추가됩니다.
//        이 스택 프레임은 메서드 실행 중에 필요한 모든 정보를 포함합니다.
//        메서드의 실행이 완료되면 해당 메서드의 스택 프레임이 스택에서 제거되고,
//        제거되는 동안 메서드의 반환 값이 이전 스택 프레임에 반환됩니다.


//        재귀 호출:
//
//        재귀 함수는 자신을 호출하는 메서드입니다.
//        재귀 호출은 콜 스택에서 여러 개의 복제된 스택 프레임을 만들 수 있으며,
//        이로 인해 스택의 깊이가 증가할 수 있습니다. 이를 재귀 호출 스택이라고 합니다.
//        재귀 호출이 종료 조건을 만족하면, 스택에서 스택 프레임이 하나씩 제거되면서 재귀 호출이 해결됩니다.
//        에러 추적:
//
//        예외가 발생하거나 오류가 발생할 때, 콜 스택은 에러 추적(error traceback)을 생성합니다.
//        이것은 어떤 메서드 호출에서 문제가 발생했는지를 확인하는 데 사용됩니다.


//        스택 오버플로우:
//
//        스택은 제한된 크기를 가지며, 메서드 호출이 지나치게 깊어질 경우 스택 오버플로우(Stack Overflow)가 발생할 수 있습니다.
//        이는 일반적으로 재귀 호출에서 종료 조건이 충족되지 않아서 스택이 계속 성장할 때 발생합니다.
//        콜 스택은 자바 프로그램의 중요한 부분이며, 메서드 호출의 관리와 에러 추적을 가능하게 합니다.
//        프로그래머는 적절하게 메서드를 호출하고 반환하는 방법을 고려하여 콜 스택을 효과적으로 관리해야 합니다.
//        이를 통해 메모리 및 실행 시간을 효율적으로 사용할 수 있고, 스택 오버플로우와 같은 문제를 방지할 수 있습니다.

package Chapter06_OOP;

public class Ex6_22_call_Stack {
    public class CallStackExample {

        public static void main(String[] args) {
            int result = factorial(5);
            System.out.println("팩토리얼 결과: " + result);
        }

        public static int factorial(int n) {
            if (n == 0) {
                return 1; // 종료 조건: 0! = 1
            } else {
                int recursiveResult = factorial(n - 1);
                int result = n * recursiveResult;
                System.out.println("factorial(" + n + ") = " + result);
                return result;
            }
        }
    }

}
